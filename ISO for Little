Oui, trÃ¨s bon cas dâ€™usage â€” et tu as bien compris le piÃ¨ge classique de Spring Security ğŸ‘Œ
Je te donne la faÃ§on propre, standard et safe de faire Ã§a, avec whitelist + accÃ¨s au repository, sans que ton filtre soit injectÃ© nâ€™importe oÃ¹.

â¸»

âœ… Le vrai problÃ¨me

Tu veux :

âœ… Un filtre custom
âœ… Quâ€™il soit bypass sur certaines URLs (whitelist)
âœ… Quâ€™il ait accÃ¨s Ã  UserRepository
âœ… Sans que Spring lâ€™insÃ¨re automatiquement dans la chaÃ®ne Ã  cause dâ€™un @Bean

Et tu as raison :

âŒ Si tu dÃ©clares ton filtre en @Bean, Spring Security peut lâ€™ajouter nâ€™importe oÃ¹ dans la chaÃ®ne.

â¸»

âœ… âœ… LA BONNE SOLUTION (celle quâ€™il faut utiliser en prod)

ğŸ‘‰ Tu NE dÃ©clares PAS ton filtre en @Bean
ğŸ‘‰ Tu lâ€™injectes via le constructeur de ton SecurityConfig
ğŸ‘‰ Tu lâ€™ajoutes manuellement dans securityFilterChain
ğŸ‘‰ Tu gÃ¨res la whitelist DIRECTEMENT dans le filtre

â¸»

âœ… 1ï¸âƒ£ Ton filtre (avec accÃ¨s au repository + whitelist)

@Component
public class ApiKeyAuthFilter extends OncePerRequestFilter {

    private final UserRepository userRepository;

    private static final List<String> WHITELIST = List.of(
            "/api/auth/login",
            "/api/auth/register",
            "/actuator/health",
            "/v3/api-docs",
            "/swagger-ui"
    );

    public ApiKeyAuthFilter(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        String path = request.getServletPath();
        return WHITELIST.stream().anyMatch(path::startsWith);
    }

    @Override
    protected void doFilterInternal(
            HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain
    ) throws ServletException, IOException {

        String apiKey = request.getHeader("X-API-KEY");

        if (apiKey == null || apiKey.isBlank()) {
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            response.getWriter().write("Missing API Key");
            return;
        }

        User user = userRepository.findByApiKey(apiKey)
                .orElse(null);

        if (user == null) {
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            response.getWriter().write("Invalid API Key");
            return;
        }

        // âœ… CrÃ©e le user dans le contexte Spring Security
        UsernamePasswordAuthenticationToken authentication =
                new UsernamePasswordAuthenticationToken(user, null, List.of());

        SecurityContextHolder.getContext().setAuthentication(authentication);

        filterChain.doFilter(request, response);
    }
}

âœ… Ici :
	â€¢	Le filtre a le repository via constructeur
	â€¢	La whitelist est gÃ©rÃ©e PROPREMENT
	â€¢	Le filtre est totalement bypassÃ© sur les routes autorisÃ©es
	â€¢	Aucune logique dÃ©gueulasse dans la config

â¸»

âœ… 2ï¸âƒ£ Ta config Spring Security (PAS DE @Bean POUR LE FILTRE)

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    private final ApiKeyAuthFilter apiKeyAuthFilter;

    public SecurityConfig(ApiKeyAuthFilter apiKeyAuthFilter) {
        this.apiKeyAuthFilter = apiKeyAuthFilter;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        return http
                .csrf(AbstractHttpConfigurer::disable)

                .authorizeHttpRequests(auth -> auth
                        .requestMatchers(
                                "/api/auth/**",
                                "/swagger-ui/**",
                                "/v3/api-docs/**",
                                "/actuator/**"
                        ).permitAll()
                        .anyRequest().authenticated()
                )

                // âœ… ON Lâ€™INSÃˆRE MANUELLEMENT
                .addFilterBefore(apiKeyAuthFilter, UsernamePasswordAuthenticationFilter.class)

                .build();
    }
}

âœ… Le filtre :
	â€¢	Est dans la bonne position
	â€¢	Est maÃ®trisÃ© Ã  100%
	â€¢	Est bypassÃ© sur la whitelist DEUX FOIS (security + filtre)

â¸»

âœ… Pourquoi il ne faut PAS Ã©viter @Component ici

Tu avais peur que :

â€œSi je mets le filtre en Bean, Spring va lâ€™injecter nâ€™importe oÃ¹â€

ğŸ‘‰ Ce nâ€™est vrai que si tu fais :

@Bean
public ApiKeyAuthFilter apiKeyAuthFilter() { ... }

âœ… En revanche, avec :

@Component
public class ApiKeyAuthFilter extends OncePerRequestFilter

Spring :
	â€¢	Ne lâ€™insÃ¨re NULLE PART automatiquement
	â€¢	Il est juste disponible pour injection
	â€¢	TOI seul contrÃ´les oÃ¹ il va dans la chaÃ®ne

Donc tu es totalement safe âœ…

â¸»

âœ… Alternative propre si tu REFUSES vraiment @Component

Tu peux faire :

@Configuration
public class FilterConfig {

    @Bean
    public ApiKeyAuthFilter apiKeyAuthFilter(UserRepository userRepository) {
        return new ApiKeyAuthFilter(userRepository);
    }
}

Et dans SecurityConfig :

.addFilterBefore(apiKeyAuthFilter, UsernamePasswordAuthenticationFilter.class)

âœ… Toujours safe
âŒ Le filtre nâ€™est jamais auto-ajoutÃ©

â¸»

âœ… RÃ©cap clair

ProblÃ¨me	Solution
AccÃ¨s au repository	âœ… Injection via constructeur
Whitelist	âœ… shouldNotFilter()
ContrÃ´le de lâ€™ordre	âœ… addFilterBefore()
Bypass sÃ©curitÃ©	âœ… permitAll()
Filtre non auto-injectÃ©	âœ… Pas de @Bean direct


â¸»

âœ… Si tu veux, je peux aussi te fournir :
	â€¢	âœ… Une version avec JWT + API Key
	â€¢	âœ… Une version avec cache Redis
	â€¢	âœ… Une version avec Spring AuthorizationManager
	â€¢	âœ… Une version compatible Spring Security 6.2+

â¸»

ğŸ‘‰ Si tu veux, envoie-moi :
	â€¢	Ton filtre actuel
	â€¢	Ta classe SecurityConfig

Et je te la corrige ligne par ligne pour que Ã§a marche parfaitement. ğŸ”¥