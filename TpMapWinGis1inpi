You’re right — the simple loop will not work for AMOUNT because it needs special comparison logic (689 vs 689,00).

No problem — we can still keep the clean loop and add a special case only for AMOUNT.

Below is the best clean solution.

⸻

✅ Final Clean Version — Loop + special handling for AMOUNT

private String validateInputMatchesDb(SctDebitData input) {
    SctDebitPdfContent db = getContent(input.getOrderId());
    SctDebitPdfContent in = mapToContent(input);

    Map<String, String> checks = Map.of(
        SctDebitPdfContent.SUPPLIER_NAME, "supplierName mismatch",
        SctDebitPdfContent.SUPPLIER_IBAN, "supplierIban mismatch",
        SctDebitPdfContent.OUT_NAME, "outName mismatch",
        SctDebitPdfContent.OUT_IBAN, "outIban mismatch",
        SctDebitPdfContent.OUT_ADDRESS, "outAddress mismatch",
        SctDebitPdfContent.AMOUNT, "amount mismatch",
        SctDebitPdfContent.EXECUTION_DATE, "executionDate mismatch",
        SctDebitPdfContent.LABEL, "label mismatch",
        SctDebitPdfContent.END_TO_END_ID, "endToEndId mismatch",
        SctDebitPdfContent.TX_ID, "txId mismatch",
        SctDebitPdfContent.CONTROL_KEY, "controlKey mismatch"
    );

    for (var entry : checks.entrySet()) {
        String field = entry.getKey();
        String message = entry.getValue();

        // Special handling for AMOUNT
        if (field.equals(SctDebitPdfContent.AMOUNT)) {
            if (!amountEquals(in.getField(field), db.getField(field))) {
                return message;
            }
        } else {
            if (!Objects.equals(in.getField(field), db.getField(field))) {
                return message;
            }
        }
    }

    return null;
}


⸻

✅ Amount comparison method

This will correctly match:
	•	"689" ↔ "689,00"
	•	"689.00" ↔ "689,00"
	•	"689,50" ↔ "689.50"

private boolean amountEquals(String inVal, String dbVal) {
    if (inVal == null || dbVal == null)
        return Objects.equals(inVal, dbVal);

    // Normalize:
    // - replace comma by dot
    // - parse as BigDecimal (safest)
    BigDecimal inDec = new BigDecimal(inVal.replace(",", "."));
    BigDecimal dbDec = new BigDecimal(dbVal.replace(",", "."));

    return inDec.compareTo(dbDec) == 0;
}


⸻

⭐ Result
	•	Your method becomes short and clean
	•	All fields are handled generically
	•	AMOUNT is handled safely with decimal logic
	•	You eliminate duplicate comparison lines

⸻

If you want, I can help you clean up the SctDebitPdfContent class as well.