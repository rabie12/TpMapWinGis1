Oui — possible. Mais avant tout : restons pragmatiques. Si tes @Schema(nullable = true) ne sont pas pris en compte par SpringDoc, ça peut venir de 3 causes principales :
	1.	SpringDoc / Spring Boot / dépendances inconsistantes (versions multiples / jars en cache).
	2.	SpringDoc n’analyse pas l’annotation à l’endroit où tu l’as posée (champ vs getter vs Jackson).
	3.	Le customizer n’est pas chargé / pas exécuté (mauvais package, classe non scannée, build pas propre).

Je te donne ci-dessous la check-list + le code minimal à ajouter (configuration OpenAPI + customizers) et les actions de debug. Fais-les dans l’ordre — ça résout presque toujours le problème.

⸻

1) Vérifie les versions (obligatoire)

Exécute dans ton projet :

mvn dependency:tree | sed -n '1,200p' | grep -E "springdoc|spring-boot"

Tu dois avoir une seule version de springdoc-openapi-starter-webmvc-ui compatible avec ta version de Spring Boot. Pas de mélange 3.0.0-M1 + 2.x + Boot 3.3.x. Poste le résultat si tu veux que je regarde.

⸻

2) Force OpenAPI 3.1 (config) — ajoute ce bean

src/main/java/eu/olkypay/business_registry/config/OpenApiConfig.java

package eu.olkypay.business_registry.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {
    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .openapi("3.1.0")
                .info(new Info().title("Business Registry API").version("1.0"));
    }
}

Cela force SpringDoc à exposer openapi: "3.1.0" et évite que des valeurs par défaut 3.0 soient utilisées.

⸻

3) PropertyCustomizer (force oneOf pour string|null)

src/main/java/eu/olkypay/business_registry/config/NullablePropertyCustomizer.java

package eu.olkypay.business_registry.config;

import io.swagger.v3.oas.models.media.Schema;
import org.springdoc.core.customizers.PropertyCustomizer;
import org.springframework.stereotype.Component;

import java.lang.reflect.Type;
import java.util.List;

@Component
public class NullablePropertyCustomizer implements PropertyCustomizer {
    @Override
    public Schema<?> customize(Schema<?> property, Type type) {
        if (property == null) return null;
        if (Boolean.TRUE.equals(property.getNullable()) && "string".equals(property.getType())) {
            Schema<?> s1 = new Schema<>().type("string");
            Schema<?> s2 = new Schema<>().type("null");
            property.setOneOf(List.of(s1, s2));
            property.setType(null);
            property.setNullable(null);
        }
        return property;
    }
}

Place-le dans un package scanné par Spring (même racine eu.olkypay...). Rebuild.

⸻

4) (Backup) OpenApiCustomizer — post-traitement global

Si certaines propriétés ne sont pas marquées nullable mais doivent l’être, ajoute aussi ceci :

package eu.olkypay.business_registry.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.media.Schema;
import org.springdoc.core.customizers.OpenApiCustomizer;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Map;

@Component
public class OpenApiNullablePostProcessor implements OpenApiCustomizer {
    @Override
    public void customise(OpenAPI openApi) {
        if (openApi == null || openApi.getComponents() == null) return;
        Map<String, Schema> schemas = openApi.getComponents().getSchemas();
        if (schemas == null) return;
        schemas.values().forEach(schema -> {
            if (schema.getProperties() == null) return;
            schema.getProperties().forEach((k, v) -> {
                if (!(v instanceof Schema)) return;
                Schema<?> p = (Schema<?>) v;
                if ("string".equals(p.getType()) && Boolean.TRUE.equals(p.getNullable())) {
                    Schema<?> s1 = new Schema<>().type("string");
                    Schema<?> s2 = new Schema<>().type("null");
                    p.setOneOf(List.of(s1, s2));
                    p.setType(null);
                    p.setNullable(null);
                }
            });
        });
    }
}


⸻

5) Où mettre @Schema ? (champ vs getter)

SpringDoc s’appuie sur l’introspection Jackson. Avec Lombok, parfois annoter le getter fonctionne mieux :

@Data
public class AddressDTO {
    private String zipCode;

    @Schema(nullable = true, example = "75015")
    public String getZipCode() { return zipCode; }
}

Si tes @Schema sont sur les champs et que ça ne marche pas, essaye de les mettre sur les getters (test rapide).

⸻

6) application.properties (valeurs à conserver)

springdoc.api-docs.version=OPENAPI_3_1
springdoc.model-converters.nullable-properties=true


⸻

7) Nettoyage + rebuild (très important)

mvn clean
mvn -U package -DskipTests

Puis démarrer (mvn spring-boot:run ou via IntelliJ Run). Vider cache navigateur et ouvrir /v3/api-docs.

⸻

8) Logs debug utiles

Active le debug SpringDoc pour voir si le customizer est appelé :

logging.level.org.springdoc=DEBUG
logging.level.org.springdoc.core.customizers=DEBUG

Redémarre et cherche dans les logs des messages d’exécution de tes NullablePropertyCustomizer / OpenApiNullablePostProcessor.

⸻

9) Si ça ne marche toujours pas — envoie-moi ces 3 choses
	1.	Le fragment de /v3/api-docs autour du champ (ex. Address → zipCode).
	2.	Le résultat de : mvn dependency:tree | grep springdoc -n
	3.	Ton pom.xml (parent + dependencies) — uniquement la partie <parent> et <dependencies>.

Avec ces 3 éléments je corrige pour TON cas précis (incompatibilité, doublon, ou annotation mal placée).

⸻

Résumé rapide (action immédiate)
	1.	Ajoute OpenApiConfig (force 3.1).
	2.	Ajoute NullablePropertyCustomizer (fourni ci-dessus).
	3.	Rebuild mvn clean package.
	4.	Vérifie /v3/api-docs.
	5.	Si échec, colle ici le fragment JSON + dependency:tree + pom.xml (parent+deps).

Je te guide ensuite ligne par ligne. Tu veux que je t’envoie un paste d’exemple minimal complet (pom + DTO + controller + config) que tu peux coller et tester localement ?