package eu.olkypay.tournesol.data.export.pdf.sct;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.security.Key;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.*;

import javax.annotation.Resource;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

import eu.olkypay.tournesol.api.dto.SctDebitData;
import org.apache.commons.codec.binary.Hex;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import com.aspose.words.CustomDocumentProperties;
import com.aspose.words.Document;
import com.aspose.words.DocumentProperty;
import com.aspose.words.SaveFormat;

import eu.olkypay.framework.audit.Auditor;
import eu.olkypay.framework.audit.Diff;
import eu.olkypay.framework.util.Strings;
import eu.olkypay.tournesol.data.export.pdf.opr.OrderPaymentRecoveryPdfWriter;
import eu.olkypay.tournesol.datamodel.bb.bom.DocumentTemplate;
import eu.olkypay.tournesol.datamodel.bb.bom.Sio4Ecriture;
import eu.olkypay.tournesol.datamodel.bb.dao.AuditDao;
import eu.olkypay.tournesol.datamodel.bb.service.DocumentTemplateService;
import eu.olkypay.tournesol.datamodel.bb.service.Sio4EcritureService;
import eu.olkypay.tournesol.datamodel.enums.Categories;
import eu.olkypay.tournesol.datamodel.enums.OrderStatuses;
import eu.olkypay.tournesol.datamodel.symwis.bom.Address;
import eu.olkypay.tournesol.datamodel.symwis.bom.Client;
import eu.olkypay.tournesol.datamodel.symwis.bom.OrderLine;
import eu.olkypay.tournesol.datamodel.symwis.bom.OrderPayment;
import eu.olkypay.tournesol.datamodel.symwis.bom.Supplier;
import eu.olkypay.tournesol.datamodel.symwis.bom.Payment;
import eu.olkypay.tournesol.datamodel.symwis.bom.BankAccount;
import eu.olkypay.tournesol.datamodel.symwis.service.OrderLineService;
import eu.olkypay.tournesol.datamodel.symwis.service.OrderPaymentService;
import eu.olkypay.tournesol.api.dto.audit.AuditTrackDto;

/**
 * @formatter:off
 * 
 * Ajout de propriétés dans le template : 
 * 
 * 1/ Création des propriétés
 * - Onglet Fichier -> Dans la Select box "Propriétés", choisir "Propriétés avancées"
 * -> Ouvre un dialogue "Propriétés de nom_du_document.docx"
 * - Sélectionner l'Onglet personnalisation dans la dialogue
 *     . Donner un nom à la propriété
 *     . choisir son type
 *     . Donner une valeur
 *     . Ajouter (bouton ajouter, devient actif quand une valeur est renseignée)
 * - Répéter pour toutes les "custom properties"
 * 
 * 2/ Ajouter les propriétés dans le contenu
 * Pour placer les propriétés dans le template :
 * - Se placer, dans le contenu du document, où la propriété doit être ajoutées
 * - Onglet Insertion -> Dans le selectbox "QuickPart", choisir "Champ"
 * -> Ouvre un dialogue "Champ"
 * - Parmi les noms de champs, sélectionner "PropriétéDoc"
 * -> les propriétés créées ci-dessus (1/) s'affichent dans une liste "Propriétés du champ"
 * - Sélectionner le champ à ajouter
 * - clicker sur OK
 * 
 * @formatter:on
 * 
 * 
 * @author jchevalier
 *
 */
@Service(SctDebitPdfWriter.BEAN_NAME)
public class SctDebitPdfWriter {

    private static final Logger LOGGER = LoggerFactory.getLogger(OrderPaymentRecoveryPdfWriter.class);

    public static final String BEAN_NAME = "sctDebitPdfWriter";

    private static final String SCT_TEMPLATE = "SCT_TEMPLATE";
    private static final NumberFormat NUMBER_FORMAT = new DecimalFormat("###,###,###,##0.00");
    private static String KEY_ENCODER = "keyProut9876olkY";

    DateTimeFormatter DTF = DateTimeFormatter.ofPattern("dd/MM/uuuu");

    @Resource(name = DocumentTemplateService.BEAN_NAME)
    private DocumentTemplateService _docTemplateSvc;

    @Resource(name = OrderLineService.BEAN_NAME)
    private OrderLineService _orderLineSvc;

    @Resource(name = OrderPaymentService.BEAN_NAME)
    private OrderPaymentService _orderPaymentSvc;

    @Resource(name = Sio4EcritureService.BEAN_NAME)
    private Sio4EcritureService _sio4EcritureService;
    
    @Resource(name = AuditDao.BEAN_NAME)
    private AuditDao _auditDao;

    /**
     * From document template, as pdf
     * 
     * @param orderId
     * @return
     * @throws Exception
     */
    @Transactional(propagation = Propagation.SUPPORTS, readOnly = true)
    public byte[] generateDocument(Integer orderId) throws Exception {
        return generate(orderId, null, SaveFormat.PDF);
    }

    /**
     * From document template, as docx
     * 
     * @param orderId
     * @return
     * @throws Exception
     */
    @Transactional(propagation = Propagation.SUPPORTS, readOnly = true)
    public byte[] generateDocumentDocx(Integer orderId) throws Exception {
        return generate(orderId, null, SaveFormat.DOCX);
    }

    /**
     * From template passed as parameter, as pdf
     * 
     * @param orderId
     * @param templateIs
     * @return
     * @throws Exception
     */
    @Transactional(propagation = Propagation.SUPPORTS, readOnly = true)
    public byte[] generateDocument(Integer orderId, InputStream templateIs) throws Exception {
        return generate(orderId, Auditor.getTx(), templateIs, SaveFormat.PDF);
    }

    private byte[] generate(Integer orderId, String txId, int saveFormat) throws Exception {
        DocumentTemplate documentTemplate = _docTemplateSvc.findLastVersionActive(SCT_TEMPLATE);
        return generate(orderId, txId, new ByteArrayInputStream(documentTemplate.getContent()), saveFormat);
    }

    private byte[] generate(Integer orderId, String txId, InputStream isTemplate, int saveFormat) throws Exception {
        LOGGER.info("Generating SCT document for order with id <{}>", orderId);
        Document document = new Document(isTemplate);

        CustomDocumentProperties cdp = document.getCustomDocumentProperties();
        document.getBuiltInDocumentProperties().setTitle("Avis de débit");
        document.getBuiltInDocumentProperties().setAuthor("Olkypay");
        document.getBuiltInDocumentProperties().setCompany("Olkypay");
        document.getBuiltInDocumentProperties().setKeywords(String.format("%s %s", orderId, (txId != null ? txId : "")));

        setDocumentProperties(cdp, getContent(orderId));
        document.updateFields();

        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        document.save(baos, saveFormat);
        return baos.toByteArray();

    }

    public byte[] generatePdf(SctDebitData data) throws Exception {
        LOGGER.info("Generating SCT document for order <{}>", data.getOrderId());

        DocumentTemplate documentTemplate = _docTemplateSvc.findLastVersionActive(SCT_TEMPLATE);
        Document document = new Document(new ByteArrayInputStream(documentTemplate.getContent()));

        document.getBuiltInDocumentProperties().setTitle("Avis de débit");
        document.getBuiltInDocumentProperties().setAuthor("Olkypay");
        document.getBuiltInDocumentProperties().setCompany("Olkypay");
        document.getBuiltInDocumentProperties().setKeywords(
                String.format("%s %s", data.getOrderId(),
                        Optional.ofNullable(data.getTxId()).orElse(""))
        );
        SctDebitPdfContent content = mapToContent(data);
        CustomDocumentProperties cdp = document.getCustomDocumentProperties();
        setDocumentProperties(cdp, content);
        document.updateFields();
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        document.save(baos, SaveFormat.PDF);
        return baos.toByteArray();
    }

    private SctDebitPdfContent mapToContent(SctDebitData data) {
        SctDebitPdfContent content = new SctDebitPdfContent();
        content.setSupplierName(data.getSupplierName());
        content.setSupplierIban(data.getSupplierIban());
        content.setOutName(data.getOutName());
        content.setOutIban(data.getOutIban());
        content.setOutAddress(data.getOutAddress());
        if (data.getAmount() != null) {
            content.setAmount(data.getAmount().stripTrailingZeros().toPlainString());
        } else {
            content.setAmount("0.00");
        }
        content.setExecutionDate(data.getExecutionDate());
        content.setLabel(data.getLabel());
        content.setEndToEndId(data.getEndToEndId());
        content.setTxId(data.getTxId());
        content.setControlKey(data.getTxId());
        return content;
    }

    private SctDebitPdfContent getContent(int orderPaymentId) {
        SctDebitPdfContent result = new SctDebitPdfContent();
        OrderPayment orderPayment = _orderPaymentSvc.findByPrimaryKey(orderPaymentId);

        if (orderPayment == null) {
            throw new IllegalArgumentException("No OrderPayment found");
        }
        if (Categories.SCT.getCategory().getId() != orderPayment.getCategory().getId() && Categories.IP.getCategory().getId() != orderPayment.getCategory().getId()) {
            throw new IllegalArgumentException("Not an SCT");
        }
        if (OrderStatuses.COMPLETED.getOrderStatus().getId() != orderPayment.getOrderStatus().getId()) {
            throw new IllegalArgumentException("Not a completed Order");
        }
        // Client...
        Client client = orderPayment.getClient();
        String clientName = client.getFullName();
        
        
        Address clientAddress = client.getAddress();
        if (clientAddress == null) {
            throw new IllegalArgumentException("No address for client");
        }
        StringBuilder address = new StringBuilder().append(clientAddress.getAddress1()).append(", ");
        if (!Strings.isEmpty(clientAddress.getPostcode())) {
            address.append(clientAddress.getPostcode()).append(" ");
        }
        result.setOutAddress(address.append(clientAddress.getCity()).toString());
        Supplier supplier = client.getSupplier();
        // Supplier name
        result.setSupplierName(supplier.getFullname());
        // Order lines
        OrderLine orderLine = null;
        List<OrderLine> orderLines = _orderLineSvc.findByOrderPaymentId(orderPaymentId);
        if (orderLines != null) {
            for (OrderLine ol : orderLines) {
                if (OrderStatuses.COMPLETED.getOrderStatus().getId() == ol.getOrderStatus().getId()) {
                    orderLine = ol;
                    result.setExecutionDate(ol.getSddSettlementDate().format(DTF));
                    break;
                }
            }
        }
        if (orderLine == null) {
            throw new IllegalArgumentException("No completed OrderLine for Order");
        }
        
        result.setEndToEndId(orderPayment.getEndToEndId());
        result.setTxId(orderLine.getPacsTxId());
        
        Payment orderLinePayment = orderLine.getPayment();
        if (orderLinePayment != null) {
        	BankAccount orderLineBankAccount = orderLinePayment.getBankAccount();
        	if (orderLineBankAccount != null) {
        		clientName = orderLineBankAccount.getName();
        	}
        }
        
        result.setOutName(clientName);
        
        
        List<Sio4Ecriture> ecritures = _sio4EcritureService.findByCodeOrderLineWis(orderLine.getId());
        if (ecritures == null || ecritures.isEmpty()) {
            throw new IllegalArgumentException("Not Ecritures for OrderLine");
        }
        
        
        for (Sio4Ecriture e : ecritures) {
            if (e.getCredit() != null && e.getCredit() > 0) {
                result.setAmount(convertAmount(e.getCredit()));
                result.setOutIban(e.getIban());
                
                result.setControlKey(encodeControlKey(String.valueOf(e.getIdCtp())));
            } else if (e.getDebit() != null && e.getDebit() > 0) {
                result.setSupplierIban(e.getIban());
            }
        }
        if (!Strings.isEmpty(orderPayment.getComment())) {
            result.setLabel(orderPayment.getComment());
        }

        return result;
    }

    public boolean checkControlKey(int orderId, String key) {
        if (Strings.isBlank(key)) {
            return false;
        }
        OrderLine orderLine = null;
        List<OrderLine> orderLines = _orderLineSvc.findByOrderPaymentId(orderId);
        if (orderLines != null) {
            for (OrderLine ol : orderLines) {
                if (OrderStatuses.COMPLETED.getOrderStatus().getId() == ol.getOrderStatus().getId()) {
                    orderLine = ol;
                    break;
                }
            }
        }
        if (orderLine == null) {
            return false;
        }
        List<Sio4Ecriture> ecritures = _sio4EcritureService.findByCodeOrderLineWis(orderLine.getId());
        if (ecritures == null || ecritures.isEmpty()) {
            return false;
        }
        String controlKey = null;
        for (Sio4Ecriture e : ecritures) {
            if (e.getCredit() != null && e.getCredit() > 0) {
                controlKey = encodeControlKey(String.valueOf(e.getIdCtp()));
            }
        }
        return controlKey != null ? key.equals(controlKey) : false;

    }

    private String encodeControlKey(String data) {

        try {
            // Create key and cipher
            Key aesKey = new SecretKeySpec(KEY_ENCODER.getBytes(), "AES");
            Cipher cipher = Cipher.getInstance("AES");

            // encrypt the text
            cipher.init(Cipher.ENCRYPT_MODE, aesKey);
            byte[] encrypted = cipher.doFinal(data.getBytes());

            return Hex.encodeHexString(encrypted);
        } catch (Exception e) {
            // handle exception
            LOGGER.error("FAILED TO ENCODE CONTROL KEY");
            return null;
        }
    }

    @SuppressWarnings("unchecked")
    private void setDocumentProperties(CustomDocumentProperties cdp, SctDebitPdfContent content) {
        Iterator<DocumentProperty> iterator = cdp.iterator();
        while (iterator.hasNext()) {
            DocumentProperty dp = iterator.next();
            String value = content.getField(dp.getName());
            dp.setValue(value == null ? "" : value);
        }
    }

    private String convertAmount(long value) {
        if (value == 0) {
            return "";
        }
        return NUMBER_FORMAT.format((double) value / 100);
    }

}
en bas memes deux api's


    @RequestMapping(value = "/{orderId}/", method = RequestMethod.GET)
    public ResponseEntity<byte[]> generate(@PathVariable("orderId") int orderId) throws Exception {
        LOGGER.info("Sct request for SCT order with ID <{}>", orderId);
        byte[] content = _sctDebitPdfWriter.generateDocument(orderId);
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_PDF);
        String filename = new StringBuilder("Avis-débit-").append(orderId).append(".pdf").toString();
        headers.setContentDispositionFormData(filename, filename);
        headers.setCacheControl("must-revalidate, post-check=0, pre-check=0");
        ResponseEntity<byte[]> response = new ResponseEntity<byte[]>(content, headers, HttpStatus.OK);
        return response;
    }

    @PostMapping(value = "/generate", produces = MediaType.APPLICATION_PDF_VALUE)
    public ResponseEntity<?> generate(@RequestBody SctDebitData data) throws Exception {
        String validationError = validateSctDebitData(data);
        Map<String, String> errorBody = new HashMap<>();
        errorBody.put("error", validationError);
        if (validationError != null) {
            LOGGER.warn("Invalid input for order: {} -> {}", data.getOrderId(), validationError);
            return ResponseEntity
                    .status(HttpStatus.BAD_REQUEST)
                    .contentType(MediaType.APPLICATION_JSON)
                    .body(errorBody);
        }
        byte[] pdf = _sctDebitPdfWriter.generatePdf(data);
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_PDF);
        String filename = String.format("Avis-debit-%d.pdf", data.getOrderId());
        headers.setContentDispositionFormData(filename, filename);
        headers.setCacheControl("must-revalidate, post-check=0, pre-check=0");
        LOGGER.info("PDF generated successfully for order <{}>", data.getOrderId());
        return new ResponseEntity<>(pdf, headers, HttpStatus.OK);
    }

est-ce que je peux utiliser le mm getContent pour verifier la corespondence de SctDebitDataaux order_payment enDB
