Great ‚Äî this makes the situation much clearer.

Your representative object is:

RepresentativeDTO(
  role=DIRECTEUR_GENERAL,
  naturalPerson=...,
  legalEntity=null
)

‚û°Ô∏è So for this representative, legalEntity is NULL.

But your code does:

if (representativeDTO.getLegalEntity() != null) {
    if (representativeDTO.getLegalEntity().getLegalForm() != null) {
        Optional<LegalFormINPIMatching> legalFormINPIMatchingRepresentatives =
            legalFormINPIMatchingRepository.findById(
                Integer.valueOf(representativeDTO.getLegalEntity().getLegalForm())
            );
        representativeDTO.getLegalEntity().setLegalForm(legalFormINPIMatchingRepresentatives.get().getLabel());
    }
}

In your case:

representativeDTO.getLegalEntity() = null

So the inner block is not executed ‚Üí OK.

So why did you get the NumberFormatException earlier?

üëâ Because the failing representative was NOT this one.

You are printing the representative that works (the natural person).
But at least ONE representative in the list is a legal entity, and THAT one has:

legalEntity.getLegalForm() = "Soci√©t√© par actions simplifi√©e"

Which is why your code crashed.

‚∏ª

üîç Conclusion
	‚Ä¢	This representative (Arthur-L√©o) is not the problem.
	‚Ä¢	Another representative in your list has a non-null legalEntity with a textual legalForm.
	‚Ä¢	That textual legalForm is causing the NumberFormatException.

‚∏ª

‚úÖ What to do next?

Add a debug log before parsing so you can identify the faulty representative:

for (RepresentativeDTO representativeDTO : company.getRepresentatives()) {
    if (representativeDTO.getLegalEntity() != null) {
        String legalForm = representativeDTO.getLegalEntity().getLegalForm();
        log.info("Legal form received for representative: {}", legalForm);

        if (legalForm != null && !legalForm.matches("\\d+")) {
            log.error("Unexpected legal form (not numeric): {}", legalForm);
        }

        // existing code...
    }
}

This will show you exactly which representative has the bad value.

‚∏ª

üìå Final Fix Recommendation

Replace:

Integer.valueOf(...)

With robust logic:

String legalForm = representativeDTO.getLegalEntity().getLegalForm();

if (legalForm != null && legalForm.matches("\\d+")) {
    // lookup by ID
    legalFormINPIMatchingRepository.findById(Integer.valueOf(legalForm))
        .ifPresent(match -> representativeDTO.getLegalEntity().setLegalForm(match.getLabel()));
} else {
    // lookup by label (if your DB supports it)
    legalFormINPIMatchingRepository.findByLabel(legalForm)
        .ifPresent(match -> representativeDTO.getLegalEntity().setLegalForm(match.getLabel()));
}

‚û°Ô∏è This avoids failures and makes the process stable.

‚∏ª

If you want, I can:

‚úî create a clean helper method
‚úî update your mapper
‚úî validate incoming INPI response
‚úî guide you to write a unit test

Just tell me!