Perfect — you’re on Spring 5.3.39 / Java 17, and you want to perform manual validation (no @Valid, no @NotNull, no JSR-303 bean validation).
You simply want to check the input SctDebitData before generating the PDF and return a 400 Bad Request with a clear message when something is missing or invalid.

Here’s how to do that cleanly and safely, without introducing external dependencies.

⸻

✅ Step 1 — Add Manual Validation Logic

You can validate inside your controller method or (preferably) delegate to a helper method or service to keep it clean.

Here’s the refactored controller method:

@PostMapping(value = "/generate", produces = MediaType.APPLICATION_PDF_VALUE)
public ResponseEntity<?> generate(@RequestBody SctDebitData data) throws Exception {
    // 1️⃣ Perform manual validation
    String validationError = validateSctDebitData(data);
    if (validationError != null) {
        LOGGER.warn("Invalid input for order: {} -> {}", data.getOrderId(), validationError);
        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(Map.of("error", validationError));
    }

    // 2️⃣ Generate the PDF
    byte[] pdf = _sctDebitPdfWriter.generatePdf(data);

    // 3️⃣ Prepare headers
    HttpHeaders headers = new HttpHeaders();
    headers.setContentType(MediaType.APPLICATION_PDF);
    String filename = String.format("Avis-debit-%d.pdf", data.getOrderId());
    headers.setContentDispositionFormData(filename, filename);
    headers.setCacheControl("must-revalidate, post-check=0, pre-check=0");

    LOGGER.info("PDF generated successfully for order <{}>", data.getOrderId());
    return new ResponseEntity<>(pdf, headers, HttpStatus.OK);
}


⸻

✅ Step 2 — Implement the Validation Method

Below is a simple, type-safe and readable validation method for your SctDebitData DTO:

private String validateSctDebitData(SctDebitData data) {
    if (data == null) {
        return "Request body is missing";
    }

    if (data.getOrderId() == null || data.getOrderId() <= 0) {
        return "Invalid or missing orderId";
    }
    if (isBlank(data.getTxId())) {
        return "Transaction ID (txId) is required";
    }
    if (isBlank(data.getExecutionDate())) {
        return "Execution date is required";
    }
    if (isBlank(data.getEndToEndId())) {
        return "End-to-end ID is required";
    }
    if (isBlank(data.getOutName())) {
        return "Payer name (outName) is required";
    }
    if (isBlank(data.getOutIban()) || !isValidIban(data.getOutIban())) {
        return "Invalid or missing payer IBAN (outIban)";
    }
    if (isBlank(data.getSupplierName())) {
        return "Supplier name is required";
    }
    if (isBlank(data.getSupplierIban()) || !isValidIban(data.getSupplierIban())) {
        return "Invalid or missing supplier IBAN (supplierIban)";
    }
    if (data.getAmount() == null || data.getAmount().compareTo(BigDecimal.ZERO) <= 0) {
        return "Amount must be greater than zero";
    }
    if (isBlank(data.getLabel())) {
        return "Transaction label is required";
    }

    // All good
    return null;
}

Helper methods:

private boolean isBlank(String value) {
    return value == null || value.trim().isEmpty();
}

private boolean isValidIban(String iban) {
    try {
        org.iban4j.Iban.valueOf(iban); // use iban4j to check validity
        return true;
    } catch (Exception e) {
        return false;
    }
}


⸻

✅ Step 3 — Example of Error Response

If the client sends bad input, they’ll get a 400 Bad Request with a clear JSON body:

Response (HTTP 400):

{
  "error": "Invalid or missing payer IBAN (outIban)"
}


⸻

✅ Step 4 — Optional Improvement

If you have multiple controllers doing similar validation, you can move this logic to a dedicated utility class:

public final class SctDebitValidator {
    private SctDebitValidator() {}

    public static String validate(SctDebitData data) {
        // ... same checks here
    }
}

Then call it inside your controller:

String error = SctDebitValidator.validate(data);
if (error != null) {
    return ResponseEntity.badRequest().body(Map.of("error", error));
}


⸻

✅ Summary

Goal	Solution
Validate input without @Valid	Manual Java validation method
Handle nulls and type issues	if checks + helper methods
Return HTTP 400	ResponseEntity.status(HttpStatus.BAD_REQUEST)
Support Spring 5.3.x	Fully compatible (no Jakarta Validation dependency)


⸻

Would you like me to extend the validation to include date format validation (e.g. check if executionDate is a valid ISO date)? It’s easy to add, and I can include that snippet too.