Excellent â€” youâ€™ve got two controllers that are currently overlapping in structure and naming but serve two distinct projects:
	â€¢	One for BitBang,
	â€¢	One for Tournesol.

Letâ€™s do a clean, consistent refactor so that:
	â€¢	Each controller clearly represents its project.
	â€¢	Each has its own base path (/api/bitbang/... vs /api/tournesol/...).
	â€¢	Each uses coherent class names, tags, and documentation summaries.

â¸»

âœ… Refactored Version 1 â€” BitBang

package eu.olkypay.bankInfo.web.bitbang;

import eu.olkypay.bankInfo.dto.BankInfoValidationResponse;
import eu.olkypay.bankInfo.service.BankInfoValidationService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/bitbang")
@Tag(name = "BitBang Bank Info", description = "Bank Info Validation APIs for BitBang project")
public class BitBangBankInfoController {

    private final BankInfoValidationService bankInfoValidationService;

    public BitBangBankInfoController(BankInfoValidationService bankInfoValidationService) {
        this.bankInfoValidationService = bankInfoValidationService;
    }

    @Operation(summary = "Derive BIC from IBAN (BitBang)")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "BIC successfully derived"),
            @ApiResponse(responseCode = "400", description = "Invalid IBAN format")
    })
    @PostMapping("/iban/{iban}/bic")
    public ResponseEntity<BankInfoValidationResponse> deriveBicFromIban(@PathVariable String iban) {
        BankInfoValidationResponse response = bankInfoValidationService.getBicFromIban(iban);
        if ("INVALID_IBAN".equalsIgnoreCase(response.getStatus())) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
        }
        return ResponseEntity.ok(response);
    }
}

ðŸ”¹ Changes Made
	â€¢	Renamed class â†’ BitBangBankInfoController
	â€¢	Base path â†’ /api/bitbang
	â€¢	Swagger tag â†’ "BitBang Bank Info"
	â€¢	Endpoint path â†’ /iban/{iban}/bic (RESTful and consistent)
	â€¢	Summary and responses renamed for clarity

â¸»

âœ… Refactored Version 2 â€” Tournesol

package eu.olkypay.bankInfo.web.tournesol;

import eu.olkypay.bankInfo.dto.BankInfoDTO;
import eu.olkypay.bankInfo.dto.BankInfoValidationResponse;
import eu.olkypay.bankInfo.dto.IbanSearchHistoryDTO;
import eu.olkypay.bankInfo.service.BankInfoValidationService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.ArraySchema;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.iban4j.IbanFormatException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Optional;

@RestController
@RequestMapping("/api/tournesol")
@Tag(name = "Tournesol Bank Info", description = "Bank Info Validation APIs for Tournesol project")
public class TournesolBankInfoController {

    private final BankInfoValidationService bankInfoValidationService;

    public TournesolBankInfoController(BankInfoValidationService bankInfoValidationService) {
        this.bankInfoValidationService = bankInfoValidationService;
    }

    @Operation(summary = "Validate IBAN (Tournesol)")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "IBAN validation successful",
                    content = @Content(array = @ArraySchema(schema = @Schema(implementation = IbanSearchHistoryDTO.class)))),
            @ApiResponse(responseCode = "400", description = "Invalid IBAN format")
    })
    @PostMapping("/iban/{iban}/validate")
    public ResponseEntity<?> validateIban(@PathVariable String iban) {
        try {
            Optional<IbanSearchHistoryDTO> result = bankInfoValidationService.validateIban(iban);
            return result
                    .map(ResponseEntity::ok)
                    .orElseGet(() -> ResponseEntity.status(HttpStatus.BAD_REQUEST).build());
        } catch (IbanFormatException | RuntimeException e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(e.getMessage());
        }
    }

    @Operation(summary = "Find Bank by BIC (Tournesol)")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Bank found",
                    content = @Content(array = @ArraySchema(schema = @Schema(implementation = BankInfoDTO.class)))),
            @ApiResponse(responseCode = "400", description = "Invalid BIC format")
    })
    @GetMapping("/bic/{bic}")
    public ResponseEntity<BankInfoDTO> getBankInfoByBic(@PathVariable String bic) {
        Optional<BankInfoDTO> response = bankInfoValidationService.findBankByBic(bic);
        if (response.isPresent()) {
            if ("INVALID_BIC".equalsIgnoreCase(response.get().getStatus())) {
                return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response.get());
            }
            return ResponseEntity.ok(response.get());
        }
        return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
    }

    @Operation(summary = "Validate BIC format (Tournesol)")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "BIC format validated",
                    content = @Content(schema = @Schema(implementation = BankInfoValidationResponse.class))),
            @ApiResponse(responseCode = "400", description = "Invalid BIC format")
    })
    @PostMapping("/bic/{bic}/validate")
    public ResponseEntity<BankInfoValidationResponse> validateBic(@PathVariable String bic) {
        BankInfoValidationResponse response = bankInfoValidationService.validateBic(bic);
        if ("INVALID_BIC".equalsIgnoreCase(response.getStatus())) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
        }
        return ResponseEntity.ok(response);
    }

    @Operation(summary = "Validate IBAN and BIC combination (Tournesol)")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Validation successful",
                    content = @Content(schema = @Schema(implementation = BankInfoValidationResponse.class))),
            @ApiResponse(responseCode = "400", description = "Invalid IBAN/BIC or mismatch")
    })
    @PostMapping("/iban/{iban}/bic/{bic}/validate")
    public ResponseEntity<BankInfoValidationResponse> validateIbanAndBic(
            @PathVariable String iban,
            @PathVariable String bic
    ) {
        BankInfoValidationResponse response = bankInfoValidationService.validateIbanAndBic(bic, iban);
        if ("INVALID_IBAN".equalsIgnoreCase(response.getStatus())
                || "INVALID_BIC".equalsIgnoreCase(response.getStatus())
                || "BIC_MISMATCH".equalsIgnoreCase(response.getStatus())) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
        }
        return ResponseEntity.ok(response);
    }

    @Operation(summary = "Derive BIC from IBAN (Tournesol)")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "BIC successfully derived"),
            @ApiResponse(responseCode = "400", description = "Invalid IBAN format")
    })
    @PostMapping("/iban/{iban}/bic")
    public ResponseEntity<BankInfoValidationResponse> deriveBicFromIban(@PathVariable String iban) {
        BankInfoValidationResponse response = bankInfoValidationService.getBicFromIban(iban);
        if ("INVALID_IBAN".equalsIgnoreCase(response.getStatus())) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
        }
        return ResponseEntity.ok(response);
    }
}

ðŸ”¹ Changes Made
	â€¢	Renamed class â†’ TournesolBankInfoController
	â€¢	Base path â†’ /api/tournesol
	â€¢	Swagger tag â†’ "Tournesol Bank Info"
	â€¢	All endpoint paths now follow consistent REST naming (/iban/{iban}/validate, /bic/{bic}/validate, etc.)
	â€¢	Cleaned exception handling and response consistency

â¸»

âœ… Final Naming Summary

Purpose	Old Class Name	New Class Name	Base Path
BitBang project	BitBangValidationController	BitBangBankInfoController	/api/bitbang
Tournesol project	BankInfoValidationController	TournesolBankInfoController	/api/tournesol


â¸»

Would you like me to also refactor the service interface and method names (like getBicFromIban â†’ deriveBicFromIban) to match this naming consistency?