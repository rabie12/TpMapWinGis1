Parfait ‚Äî voici comment d√©placer toute la logique de v√©rification en base dans le service, pour que ton contr√¥leur reste propre et que l‚ÄôAPI ne fasse que d√©l√©guer.

‚∏ª

üéØ Objectif
	1.	Le controller appelle le service :
pdfService.generateValidatedPdf(data)
	2.	Le service :
	‚Ä¢	charge les donn√©es DB
	‚Ä¢	compare SctDebitData ‚Üî DB
	‚Ä¢	renvoie soit une exception (validation KO), soit le PDF (validation OK)

‚∏ª

‚úÖ 1. Contr√¥leur : nettoy√©, sans logique m√©tier

@PostMapping(value = "/generate", produces = MediaType.APPLICATION_PDF_VALUE)
public ResponseEntity<?> generate(@RequestBody SctDebitData data) throws Exception {

    try {
        byte[] pdf = sctDebitService.generateValidatedPdf(data);

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_PDF);
        String filename = String.format("Avis-debit-%d.pdf", data.getOrderId());
        headers.setContentDispositionFormData(filename, filename);

        return new ResponseEntity<>(pdf, headers, HttpStatus.OK);
    } catch (InvalidSctDebitDataException ex) {
        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(Map.of("error", ex.getMessage()));
    }
}

üëâ Le controller est clean : aucune logique m√©tier, seulement la gestion HTTP.

‚∏ª

‚úÖ 2. Cr√©er une exception m√©tier propre

public class InvalidSctDebitDataException extends RuntimeException {
    public InvalidSctDebitDataException(String message) {
        super(message);
    }
}


‚∏ª

‚úÖ 3. Service : logique compl√®te (validation + comparaison + g√©n√©ration PDF)

Ton service devient l‚Äôendroit unique o√π :
	‚Ä¢	On valide les champs simples
	‚Ä¢	On charge les donn√©es DB avec orderId
	‚Ä¢	On compare SctDebitData ‚Üî order_payment
	‚Ä¢	On g√©n√®re le PDF

@Service
public class SctDebitService {

    @Autowired
    private OrderPaymentService orderPaymentService;

    @Autowired
    private SctDebitPdfWriter pdfWriter;

    public byte[] generateValidatedPdf(SctDebitData data) throws Exception {

        // 1Ô∏è‚É£ validation simple
        String basicValidation = validateSctDebitData(data);
        if (basicValidation != null) {
            throw new InvalidSctDebitDataException(basicValidation);
        }

        // 2Ô∏è‚É£ r√©cup√©ration BDD
        OrderPayment dbData = orderPaymentService.findByOrderId(data.getOrderId());
        if (dbData == null) {
            throw new InvalidSctDebitDataException("Order not found in database");
        }

        // 3Ô∏è‚É£ validation coh√©rence input ‚Üî DB
        String consistencyError = validateConsistency(data, dbData);
        if (consistencyError != null) {
            throw new InvalidSctDebitDataException(consistencyError);
        }

        // 4Ô∏è‚É£ si tout est OK ‚Üí g√©n√©ration PDF
        return pdfWriter.generatePdf(data);
    }


    // ---------------------------
    // VALIDATION SIMPLE
    // ---------------------------
    private String validateSctDebitData(SctDebitData data) {
        if (data.getOrderId() == null) return "OrderId is required";
        if (data.getSupplierIban() == null) return "Supplier IBAN missing";
        // Ajoute les r√®gles d√©j√† pr√©sentes chez toi
        return null;
    }


    // ---------------------------
    // VALIDATION DB ‚Üî INPUT
    // ---------------------------
    private String validateConsistency(SctDebitData input, OrderPayment db) {

        if (!Objects.equals(input.getSupplierName(), db.getSupplierName()))
            return "SupplierName doesn't match database";

        if (!Objects.equals(input.getSupplierIban(), db.getSupplierIban()))
            return "SupplierIban doesn't match database";

        if (!Objects.equals(input.getOutName(), db.getOutName()))
            return "OutName doesn't match database";

        if (!Objects.equals(input.getOutIban(), db.getOutIban()))
            return "OutIban doesn't match database";

        if (!Objects.equals(input.getOutAddress(), db.getOutAddress()))
            return "OutAddress doesn't match database";

        if (input.getAmount() != null &&
            db.getAmount() != null &&
            input.getAmount().compareTo(db.getAmount()) != 0)
            return "Amount mismatch";

        if (!Objects.equals(input.getExecutionDate(), db.getExecutionDate()))
            return "ExecutionDate mismatch";

        if (!Objects.equals(input.getLabel(), db.getLabel()))
            return "Label mismatch";

        if (!Objects.equals(input.getEndToEndId(), db.getEndToEndId()))
            return "EndToEndId mismatch";

        if (!Objects.equals(input.getTxId(), db.getTxId()))
            return "TxId mismatch";

        return null;
    }
}


‚∏ª

üëç R√©sultat

‚û§ Avant

Le controller contenait trop de logique m√©tier (validation DB, comparaison‚Ä¶).

‚û§ Apr√®s
	‚Ä¢	Le controller : uniquement HTTP + try/catch
	‚Ä¢	Le service : toute la logique de validation et comparaison
	‚Ä¢	Le PDF writer : uniquement g√©n√©ration du PDF

Architecture beaucoup plus propre.

‚∏ª

üìå Tu veux que je t‚Äôaide √† :

‚úî √©crire des tests unitaires pour ce service ?
‚úî g√©n√©rer automatiquement les comparaisons avec MapStruct ?
‚úî retourner une liste compl√®te d‚Äôerreurs plut√¥t qu‚Äôun seul message ?

Dis-moi !