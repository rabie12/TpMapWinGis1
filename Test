Yes ‚Äî you MUST handle this case before saving anything, because your API response clearly says:

result = failed
bicCandidates = []
bankCodeCheck = failed

When:
	‚Ä¢	result = failed
	‚Ä¢	bicCandidates is empty
	‚Ä¢	bank code is invalid

‚û°Ô∏è The IBAN is invalid or unknown.
‚û°Ô∏è You should NOT try to map BankInfo or BankAgency.
‚û°Ô∏è You should NOT access:

response.getBicCandidates().getFirst()

because the list is empty ‚Üí throws an exception.

‚∏ª

‚úÖ What you must do

Add a validation block at the beginning.

‚úî If response.result = "failed"

‚úî or no BIC candidates
‚úî or bankCodeCheck failed

‚û°Ô∏è Return a history record without bank info
‚û°Ô∏è Or return Optional.empty()

‚∏ª

‚úÖ Recommended logic

Here is the correct and safe version:

private Optional<IbanSearchHistoryDTO> fetchFromExternalApi(String ibanFormatted) {

    IbanValidationResponse response = callIbanValidationApi(ibanFormatted).block();

    if (response == null) {
        log.error("Failed to retrieve data from the external API.");
        return Optional.empty();
    }

    // ‚ö† 1. Validate response
    if (!"passed".equalsIgnoreCase(response.getResult())
            || response.getBicCandidates() == null
            || response.getBicCandidates().isEmpty()) {

        log.warn("Invalid IBAN or no BIC found for IBAN {}", ibanFormatted);

        // Save history but WITHOUT bank info
        IbanSearchHistory entity = new IbanSearchHistory(
                ibanFormatted,
                response.getResult(),
                response.toString(),
                LocalDateTime.now(),
                null  // no bankAgency
        );

        searchHistoryRepo.save(entity);
        return Optional.of(searchHistorymapper.toDTO(entity));
    }

    // ‚ö† If we reach here ‚Üí response is valid and has BIC
    String bic = response.getBicCandidates().getFirst().getBic();

    BankInfo bankInfo = bankInfoRepo.findByBic(bic).orElse(null);
    if (bankInfo == null) {
        bankInfo = bankInfoMapper.toEntity(response);
        bankInfo.setLocation(response.getCountry() != null ?
                Locale.of("", response.getCountry()).getDisplayCountry() : "");
        bankInfoRepo.save(bankInfo);
    } else if (bankInfo.getUpdatedAt().isBefore(LocalDateTime.now().minusDays(300))) {
        bankInfoMapper.updateEntityFromResponse(response, bankInfo);
        bankInfoRepo.save(bankInfo);
    }

    BankAgency bankAgency = bankAgencyRepo
            .findByBranchCodeAndBankCodeAndCountryIso2(
                    response.getBranchCode(),
                    response.getBankCode(),
                    response.getCountry()
            ).orElse(null);

    if (bankAgency == null) {
        bankAgency = bankAgencyMapper.toEntity(response);
        bankAgency.setBankInfo(bankInfo);
        bankAgencyRepo.save(bankAgency);
    } else {
        bankAgencyMapper.updateEntityFromResponse(response, bankAgency);
        bankAgencyRepo.save(bankAgency);
    }

    IbanSearchHistory entity = new IbanSearchHistory(
            ibanFormatted,
            response.getResult(),
            response.toString(),
            LocalDateTime.now(),
            bankAgency
    );

    searchHistoryRepo.save(entity);
    return Optional.of(searchHistorymapper.toDTO(entity));
}


‚∏ª

‚úî What this fixes

1. Prevents exceptions

You no longer do:

response.getBicCandidates().getFirst()

when the list is empty.

2. Still saves search history

User sees that IBAN was checked, even if invalid.

3. Avoids storing corrupted bank / branch data

Invalid IBAN ‚Üí bankCodeCheck is failed ‚Üí do NOT create BankInfo.

4. Your DTO works perfectly

Because you pass:

bankAgency = null
bankInfo = null


‚∏ª

üìå What your UI / API should return for this case

Example:

{
  "iban": "AT611904300234573201",
  "result": "failed",
  "bankInfoDTO": null,
  "bankAgencyDTO": null
}

This is correct behavior.

‚∏ª

‚úî Conclusion

‚û°Ô∏è YES, you must handle this case.
‚û°Ô∏è IBAN is invalid ‚Üí no BIC ‚Üí no bank info ‚Üí save simple history only.
‚û°Ô∏è Your code must check this before doing any mapping.

‚∏ª

If you want, I can also give you:

‚úî UI-friendly error message
‚úî A validator utility class
‚úî Custom exceptions for invalid IBANs

Just ask!