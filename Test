    private Optional<IbanSearchHistoryDTO> fetchFromExternalApi(String ibanFormatted) {
        IbanValidationResponse response = callIbanValidationApi(ibanFormatted).block();
        if (response == null) {
            log.error("Failed to retrieve data from the external API.");
            return Optional.empty();
        }
        // Create or update BankInfo using its mapper
        BankInfo bankInfo = bankInfoRepo.findByBic(response.getBicCandidates().getFirst().getBic()).orElse(null);
        if (bankInfo == null) {
            bankInfo = bankInfoMapper.toEntity(response);
            bankInfo.setLocation(response.getCountry() != null ? Locale.of("",response.getCountry()).getDisplayCountry(): "");
            bankInfoRepo.save(bankInfo);
        } else if(bankInfo.getUpdatedAt().isAfter(LocalDateTime.now().minusDays(300))){
            bankInfoMapper.updateEntityFromResponse(response, bankInfo);
            bankInfoRepo.save(bankInfo);
        }
        BankAgency bankAgency = bankAgencyRepo
                .findByBranchCodeAndBankCodeAndCountryIso2(response.getBranchCode(), response.getBankCode(), response.getCountry())
                .orElse(null);
        if (bankAgency == null) {
            bankAgency = bankAgencyMapper.toEntity(response);
            bankAgency.setBankInfo(bankInfo);
            bankAgencyRepo.save(bankAgency);
        } else {
            bankAgencyMapper.updateEntityFromResponse(response, bankAgency);
            bankAgencyRepo.save(bankAgency);
        }
        IbanSearchHistory entity = new IbanSearchHistory(ibanFormatted, response.getResult(), response.toString(),
                LocalDateTime.now(), bankAgency);
        searchHistoryRepo.save(entity);
        return Optional.of(searchHistorymapper.toDTO(entity));
    }

IbanValidationResponse(iban=AT611904300234573201, result=failed, returnCode=256, checks=[length, bank_code, iban_checksum], lengthCheck=passed, accountCheck=, bankCodeCheck=failed, ibanChecksumCheck=passed, accountValidationMethod=, accountValidation=, ibanCandidate=, ibanFormat=ATkk BBBB BCCC CCCC CCCC, formatComment=B = bank code, C = account No., bicCandidates=[], allBicCandidates=[], country=AT, bankCode=19043, bankAndBranchCode=19043, bank=, bankAddress=, bankStreet=, bankCity=, bankState=, bankPostalCode=, bankUrl=, branch=, branchCode=, inSclDirectory=no, sct=, sdd=, cor1=no, b2b=, scc=, sctInst=, sctInstReadinessDate=, accountNumber=, dataAge=, ibanListed=, ibanWwwOccurrences=0, wwwSeenFrom=, wwwSeenUntil=, ibanUrl=, urlRank=0, urlCategory=, urlMinDepth=0, urlProminence=null, ibanReportedToExist=0, ibanLastReported=, ibanFirstSeen=, balance=46804)

i have this case that i m not able to handle because the bic inside is empty should i search :

@Data
@AllArgsConstructor
@NoArgsConstructor
public class IbanSearchHistoryDTO {

    private String iban;
    private String result;
    private BankInfoDTO bankInfoDTO;
    private BankAgencyDTO bankAgencyDTO;
    @JsonIgnore
    private String responseDetails;

    public IbanSearchHistoryDTO(String iban, String result, String responseDetails) {
        this.iban = iban;
        this.result = result;
        this.responseDetails = responseDetails;
    }
}



this is my search iban history should i manage this case before and handle that is not valid
