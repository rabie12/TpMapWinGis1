
Perfect â€” so you want your controller to return exactly whatever your service returns, including any error response objects or messages it generates â€” not replace them with "INVALID_IBAN" or a new DTO.

Thatâ€™s easy to do â€” your current issue is that youâ€™re catching the exception and always overwriting the response with "INVALID_IBAN".
You just need to let the serviceâ€™s return value (or thrown response) pass through unchanged.

â¸»

âœ… Corrected controller method

@Operation(summary = "Validate Iban")
@ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Validation completed",
                content = @Content(schema = @Schema(implementation = IbanSearchHistoryDTO.class))),
        @ApiResponse(responseCode = "400", description = "Invalid IBAN", content = @Content)
})
@PostMapping("/validate/{iban}")
public ResponseEntity<?> validateIban(@PathVariable String iban) {
    try {
        // Call your service
        Optional<IbanSearchHistoryDTO> result = bankInfoValidationService.validateIban(iban);

        // âœ… Return whatever the service gave back
        return result
                .map(ResponseEntity::ok)
                // if service returned Optional.empty(), respond accordingly
                .orElseGet(() -> ResponseEntity.status(HttpStatus.BAD_REQUEST)
                        .body("No result returned from service"));
    } catch (IbanFormatException e) {
        // âœ… If your service itself throws a formatted response, pass it
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(e.getMessage());
    } catch (RuntimeException e) {
        // âœ… Let any other exceptions bubble up with their own message
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(e.getMessage());
    }
}


â¸»

ðŸ§  Notes
	1.	If your service (validateIban) already builds an error response object or DTO (for example, via updateFromExternalApi or fetchFromExternalApi), this controller will now return that same object unchanged.
	2.	Only if the service returns an empty Optional will it send a 400 with "No result returned from service".
	3.	If your service throws a custom exception that already contains a meaningful message or response body, you can even catch it and return e.getResponseBody() instead of e.getMessage().

â¸»

Would you like me to show how to adjust your service so that it returns structured error DTOs instead of throwing exceptions, making the controller even simpler (no try/catch needed)?