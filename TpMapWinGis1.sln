Parfait üëç ‚Äî tu veux donc garder exactement les m√™mes objets de r√©ponse (BicValidationResponse, IbanSearchHistoryDTO, etc.), sans changer le JSON, mais simplement faire en sorte que le code HTTP soit 400 quand le statut fonctionnel est "INVALID_IBAN", "INVALID_BIC" ou "BIC_MISMATCH".

Voici la version corrig√©e et minimale de ton BankInfoValidationController üëá

‚∏ª


@RestController
@RequestMapping("/api/bank-info")
public class BankInfoValidationController {

    private final BankInfoValidationService bankInfoValidationService;

    public BankInfoValidationController(BankInfoValidationService bankInfoValidationService) {
        this.bankInfoValidationService = bankInfoValidationService;
    }

    @Operation(summary = "Validate Iban")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Validation completed",
                    content = @Content(array = @ArraySchema(schema = @Schema(implementation = IbanSearchHistoryDTO.class)))),
            @ApiResponse(responseCode = "400", description = "Invalid IBAN", content = @Content)
    })
    @PostMapping("/validate/{iban}")
    public ResponseEntity<?> validateIban(@PathVariable String iban) {
        try {
            Optional<IbanSearchHistoryDTO> result = bankInfoValidationService.validateIban(iban);
            if (result.isPresent()) {
                return ResponseEntity.ok(result.get());
            } else {
                return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("INVALID_IBAN");
            }
        } catch (IbanFormatException e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("INVALID_IBAN");
        }
    }

    @Operation(summary = "find bank by bic")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Validation completed",
                    content = @Content(array = @ArraySchema(schema = @Schema(implementation = BankInfoDTO.class)))),
            @ApiResponse(responseCode = "400", description = "Invalid BIC", content = @Content)
    })
    @GetMapping("/bic/{bic}")
    public ResponseEntity<BankInfoDTO> getBankInfoByBic(@PathVariable String bic) {
        Optional<BankInfoDTO> response = bankInfoValidationService.findBankByBic(bic);
        if (response.isPresent()) {
            if ("INVALID_BIC".equalsIgnoreCase(response.get().getStatus())) {
                return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response.get());
            }
            return ResponseEntity.ok(response.get());
        }
        return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
    }

    @Operation(summary = "Validate BIC format only")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "BIC validation result",
                    content = @Content(schema = @Schema(implementation = BicValidationResponse.class))),
            @ApiResponse(responseCode = "400", description = "Invalid BIC")
    })
    @GetMapping("/validate/bic/{bic}")
    public ResponseEntity<BicValidationResponse> validateBic(@PathVariable String bic) {
        BicValidationResponse response = bankInfoValidationService.validateBic(bic);
        if ("INVALID_BIC".equalsIgnoreCase(response.getStatus())) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
        }
        return ResponseEntity.ok(response);
    }

    @Operation(summary = "Validate BIC and IBAN combination")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Validation result",
                    content = @Content(schema = @Schema(implementation = BicValidationResponse.class))),
            @ApiResponse(responseCode = "400", description = "Invalid IBAN/BIC or mismatch")
    })
    @PostMapping("/validate/{bic}/{iban}")
    public ResponseEntity<BicValidationResponse> validateIBANBIC(
            @RequestBody IbanInfoUtilsDTO ibanInfo,
            @PathVariable String bic,
            @PathVariable String iban
    ) {
        BicValidationResponse response = bankInfoValidationService.validateIbanAndBic(bic, iban, ibanInfo);
        if ("INVALID_IBAN".equalsIgnoreCase(response.getStatus())
                || "INVALID_BIC".equalsIgnoreCase(response.getStatus())
                || "BIC_MISMATCH".equalsIgnoreCase(response.getStatus())) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
        }
        return ResponseEntity.ok(response);
    }

    @Operation(summary = "Derive BIC from IBAN")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "BIC found"),
            @ApiResponse(responseCode = "400", description = "Invalid IBAN")
    })
    @PostMapping("/deriveBICFromIBAN/{iban}")
    public ResponseEntity<BicValidationResponse> deriveBICFromIBAN(@PathVariable String iban) {
        BicValidationResponse response = bankInfoValidationService.getBicFromIban(iban);
        if ("INVALID_IBAN".equalsIgnoreCase(response.getStatus())) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
        }
        return ResponseEntity.ok(response);
    }
}


‚∏ª

üîç Ce que fait cette version
	‚Ä¢	M√™me JSON qu‚Äôavant : les objets de r√©ponse ne changent pas.
	‚Ä¢	Code HTTP 400 d√®s que :
	‚Ä¢	status = INVALID_IBAN
	‚Ä¢	status = INVALID_BIC
	‚Ä¢	status = BIC_MISMATCH
	‚Ä¢	Code HTTP 200 sinon.
	‚Ä¢	Code 404 si aucun r√©sultat pour findBankByBic.

‚∏ª

Souhaites-tu aussi que je te montre comment tester √ßa facilement avec MockMvc (Spring Boot Test) pour v√©rifier les 400 et 200 ?