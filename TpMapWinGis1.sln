Perfect ‚Äî you want to make sure:
‚úÖ The service throws a proper structured exception (with details about the invalid IBAN).
‚úÖ The controller catches it and returns HTTP 400 (Bad Request) with the exact response object.
‚úÖ Everything else continues to work as normal (200 OK when valid, 400 when invalid).

Here‚Äôs the clean, production-ready version üëá

‚∏ª

‚úÖ 1Ô∏è‚É£ Define a custom exception

We‚Äôll give IbanFormatException the ability to carry a response object.

// package: com.yourcompany.yourproject.exception

public class IbanFormatException extends RuntimeException {
    private final BankInfoValidationResponse response;

    public IbanFormatException(String message, BankInfoValidationResponse response) {
        super(message);
        this.response = response;
    }

    public BankInfoValidationResponse getResponse() {
        return response;
    }
}


‚∏ª

‚úÖ 2Ô∏è‚É£ Service layer (validateIban)

Modified so it throws the exception with a structured response.

public Optional<IbanSearchHistoryDTO> validateIban(String iban) {
    String ibanFormatted = iban.replaceAll("\\s+", "");
    Iban ibanValue = validateIbanFormat(ibanFormatted);

    if (ibanValue == null) {
        // Build structured response
        BankInfoValidationResponse response = new BankInfoValidationResponse();
        response.setIban(iban);
        response.setStatus("INVALID_IBAN");
        response.setMessage("Invalid IBAN format: " + iban);

        // Throw custom exception with attached response
        throw new IbanFormatException("Invalid IBAN format", response);
    }

    List<BankAgency> agencies = bankAgencyRepo.findByBankCodeAndCountryIso2(
            ibanValue.getBankCode(),
            ibanValue.getCountryCode().name()
    );

    BankAgency bankAgency = agencies.isEmpty() ? null : agencies.get(0);

    if (bankAgency != null) {
        log.info("IBAN found in database and is up-to-date.");
        IbanSearchHistoryDTO dto = new IbanSearchHistoryDTO();
        dto.setIban(iban);
        dto.setBankInfoDTO(bankInfoMapper.toDto(bankAgency.getBankInfo()));
        dto.setBankAgencyDTO(bankAgencyMapper.toDTO(bankAgency));
        dto.setResult("VALID");
        return Optional.of(dto);
    }

    Optional<IbanSearchHistory> ibanSearchHistory = searchHistoryRepo.findByIban(ibanFormatted);
    if (ibanSearchHistory.isPresent()) {
        IbanSearchHistory existingRecord = ibanSearchHistory.get();
        boolean isUpToDate = existingRecord.getUpdatedAt()
                .isAfter(LocalDateTime.now().minusDays(300));

        if (isUpToDate) {
            log.info("IBAN found in database and is up-to-date.");
            return Optional.of(searchHistorymapper.toDTO(existingRecord));
        }

        log.info("IBAN found in database but outdated. Calling external API for an update.");
        return updateFromExternalApi(ibanFormatted, existingRecord);
    }

    log.info("IBAN not found in database. Calling external API.");
    return fetchFromExternalApi(ibanFormatted);
}


‚∏ª

‚úÖ 3Ô∏è‚É£ Controller (validateIban endpoint)

Catches the IbanFormatException and returns the same structured response with HTTP 400.

@Operation(summary = "Validate IBAN")
@ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Validation completed",
                content = @Content(schema = @Schema(implementation = IbanSearchHistoryDTO.class))),
        @ApiResponse(responseCode = "400", description = "Invalid IBAN",
                content = @Content(schema = @Schema(implementation = BankInfoValidationResponse.class)))
})
@PostMapping("/validate/{iban}")
public ResponseEntity<?> validateIban(@PathVariable String iban) {
    try {
        Optional<IbanSearchHistoryDTO> result = bankInfoValidationService.validateIban(iban);

        // ‚úÖ Return valid result (HTTP 200)
        return result.map(ResponseEntity::ok)
                     .orElseGet(() ->
                             ResponseEntity.status(HttpStatus.BAD_REQUEST)
                                     .body("INVALID_IBAN"));

    } catch (IbanFormatException e) {
        // ‚úÖ Return structured response from service (HTTP 400)
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(e.getResponse());

    } catch (RuntimeException e) {
        // ‚úÖ Unexpected error (HTTP 500)
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(e.getMessage());
    }
}


‚∏ª

‚úÖ Example responses

‚û° Valid IBAN

{
  "iban": "LU280019400644750000",
  "result": "VALID",
  "bankInfoDTO": { ... },
  "bankAgencyDTO": { ... }
}

‚û° Invalid IBAN format

{
  "iban": "123ABC",
  "status": "INVALID_IBAN",
  "message": "Invalid IBAN format: 123ABC"
}

‚û° Internal error

{
  "error": "Something went wrong"
}


‚∏ª

Would you like me to add a @ControllerAdvice global handler version next (so you don‚Äôt need to catch exceptions manually in every controller)?